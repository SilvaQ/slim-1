// Code generated by protoc-gen-go. DO NOT EDIT.
// source: slim.proto

package trie

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Bitmap is an array of bits.
//
// Since 0.5.10
type Bitmap struct {
	// Words contains bitmap
	//
	// Since 0.5.10
	Words []uint64 `protobuf:"varint,20,rep,packed,name=Words,proto3" json:"Words,omitempty"`
	// RankIndex speeds up rank() by pre-calculated it
	//
	// Since 0.5.10
	RankIndex []int32 `protobuf:"varint,30,rep,packed,name=RankIndex,proto3" json:"RankIndex,omitempty"`
	// SelectIndex speeds up select() by pre-calculated it
	//
	// Since 0.5.10
	SelectIndex          []int32  `protobuf:"varint,40,rep,packed,name=SelectIndex,proto3" json:"SelectIndex,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Bitmap) Reset()         { *m = Bitmap{} }
func (m *Bitmap) String() string { return proto.CompactTextString(m) }
func (*Bitmap) ProtoMessage()    {}
func (*Bitmap) Descriptor() ([]byte, []int) {
	return fileDescriptor_slim_04398d41cb3f85ea, []int{0}
}
func (m *Bitmap) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Bitmap.Unmarshal(m, b)
}
func (m *Bitmap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Bitmap.Marshal(b, m, deterministic)
}
func (dst *Bitmap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Bitmap.Merge(dst, src)
}
func (m *Bitmap) XXX_Size() int {
	return xxx_messageInfo_Bitmap.Size(m)
}
func (m *Bitmap) XXX_DiscardUnknown() {
	xxx_messageInfo_Bitmap.DiscardUnknown(m)
}

var xxx_messageInfo_Bitmap proto.InternalMessageInfo

func (m *Bitmap) GetWords() []uint64 {
	if m != nil {
		return m.Words
	}
	return nil
}

func (m *Bitmap) GetRankIndex() []int32 {
	if m != nil {
		return m.RankIndex
	}
	return nil
}

func (m *Bitmap) GetSelectIndex() []int32 {
	if m != nil {
		return m.SelectIndex
	}
	return nil
}

// VLenArray stores var-length []byte elts.
//
// Since 0.5.10
type VLenArray struct {
	// N is the max set bit index plus 1.
	//
	// Since 0.5.10
	N int32 `protobuf:"varint,10,opt,name=N,proto3" json:"N,omitempty"`
	// EltCnt is the number of present elts.
	//
	// Since 0.5.10
	EltCnt int32 `protobuf:"varint,11,opt,name=EltCnt,proto3" json:"EltCnt,omitempty"`
	// PresenceBM set 1 at the i-th bit if the i-th elt presents.
	//
	// Since 0.5.10
	PresenceBM *Bitmap `protobuf:"bytes,61,opt,name=PresenceBM,proto3" json:"PresenceBM,omitempty"`
	// PositionBM is a bitmap of starting position of every present elt.
	//
	// Since 0.5.10
	PositionBM *Bitmap `protobuf:"bytes,20,opt,name=PositionBM,proto3" json:"PositionBM,omitempty"`
	// FixedSize is set to elt size in Bytes field, if all the elts have equal sizes.
	//
	// Since 0.5.10
	FixedSize int32 `protobuf:"varint,23,opt,name=FixedSize,proto3" json:"FixedSize,omitempty"`
	// Bytes is the content in bytes
	//
	// Since 0.5.10
	Bytes                []byte   `protobuf:"bytes,30,opt,name=Bytes,proto3" json:"Bytes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VLenArray) Reset()         { *m = VLenArray{} }
func (m *VLenArray) String() string { return proto.CompactTextString(m) }
func (*VLenArray) ProtoMessage()    {}
func (*VLenArray) Descriptor() ([]byte, []int) {
	return fileDescriptor_slim_04398d41cb3f85ea, []int{1}
}
func (m *VLenArray) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VLenArray.Unmarshal(m, b)
}
func (m *VLenArray) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VLenArray.Marshal(b, m, deterministic)
}
func (dst *VLenArray) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VLenArray.Merge(dst, src)
}
func (m *VLenArray) XXX_Size() int {
	return xxx_messageInfo_VLenArray.Size(m)
}
func (m *VLenArray) XXX_DiscardUnknown() {
	xxx_messageInfo_VLenArray.DiscardUnknown(m)
}

var xxx_messageInfo_VLenArray proto.InternalMessageInfo

func (m *VLenArray) GetN() int32 {
	if m != nil {
		return m.N
	}
	return 0
}

func (m *VLenArray) GetEltCnt() int32 {
	if m != nil {
		return m.EltCnt
	}
	return 0
}

func (m *VLenArray) GetPresenceBM() *Bitmap {
	if m != nil {
		return m.PresenceBM
	}
	return nil
}

func (m *VLenArray) GetPositionBM() *Bitmap {
	if m != nil {
		return m.PositionBM
	}
	return nil
}

func (m *VLenArray) GetFixedSize() int32 {
	if m != nil {
		return m.FixedSize
	}
	return 0
}

func (m *VLenArray) GetBytes() []byte {
	if m != nil {
		return m.Bytes
	}
	return nil
}

// Clustered stores leaf prefixes and leaf ids.
//
// E.g. The 0-th clustered inner node has 3 leaves(Offsets:0, 1, 2)
// The 1-th clustered inner node has 2 leaves.
// The 0-th leaf of the 0-th clustered inner is ab
// The 1-th leaf of the 0-th clustered inner is abc
//
//      Starts       Offsets    Bytes
//           0 --->  0 -------> a
//           1 -.    1 -----.   b
//           2 .|    2 ----. `> a
//             |`->  3      |   b
//             |     4      |   c
//              `->  5      `-> a
//
// Since 0.5.12
type Clustered struct {
	// Starts[i] is the index of the first clustered leaf of the i-th clustered
	// inner node.
	Starts []uint32 `protobuf:"varint,71,rep,packed,name=Starts,proto3" json:"Starts,omitempty"`
	// Offsets stores the offset of every record, plus one last
	// offset equals to len(Bytes).
	//
	// To read records[i]: Bytes[Offsets[i]: Offsets[i+1]]
	Offsets []uint32 `protobuf:"varint,11,rep,packed,name=Offsets,proto3" json:"Offsets,omitempty"`
	// Bytes are packed records.
	Bytes                []byte   `protobuf:"bytes,21,opt,name=Bytes,proto3" json:"Bytes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Clustered) Reset()         { *m = Clustered{} }
func (m *Clustered) String() string { return proto.CompactTextString(m) }
func (*Clustered) ProtoMessage()    {}
func (*Clustered) Descriptor() ([]byte, []int) {
	return fileDescriptor_slim_04398d41cb3f85ea, []int{2}
}
func (m *Clustered) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Clustered.Unmarshal(m, b)
}
func (m *Clustered) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Clustered.Marshal(b, m, deterministic)
}
func (dst *Clustered) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Clustered.Merge(dst, src)
}
func (m *Clustered) XXX_Size() int {
	return xxx_messageInfo_Clustered.Size(m)
}
func (m *Clustered) XXX_DiscardUnknown() {
	xxx_messageInfo_Clustered.DiscardUnknown(m)
}

var xxx_messageInfo_Clustered proto.InternalMessageInfo

func (m *Clustered) GetStarts() []uint32 {
	if m != nil {
		return m.Starts
	}
	return nil
}

func (m *Clustered) GetOffsets() []uint32 {
	if m != nil {
		return m.Offsets
	}
	return nil
}

func (m *Clustered) GetBytes() []byte {
	if m != nil {
		return m.Bytes
	}
	return nil
}

// Slim is the internal structure of slim trie and other slim data structure.
// It is NOT a public type and do not rely on it.
// Since protobuf just makes all message public.
//
// Since 0.5.10
type Slim struct {
	// BigInnerCnt is number of big (257 bit) inner node.
	//
	// Since 0.5.10
	BigInnerCnt int32 `protobuf:"varint,11,opt,name=BigInnerCnt,proto3" json:"BigInnerCnt,omitempty"`
	// ShortSize is the number of bit of short bitmap that reduce most memory
	// cost.
	//
	// Since 0.5.10
	ShortSize int32 `protobuf:"varint,14,opt,name=ShortSize,proto3" json:"ShortSize,omitempty"`
	// NodeTypeBM is a bitmap in which a "1" indicates the i-th node is an inner
	// node, otherwise it is a leaf.
	//
	// Since 0.5.10
	NodeTypeBM *Bitmap `protobuf:"bytes,20,opt,name=NodeTypeBM,proto3" json:"NodeTypeBM,omitempty"`
	// Inners is a array of var-length node label bitmaps.
	// The size of an element bitmap is aligned to 4.
	//
	// Since 0.5.10
	Inners *Bitmap `protobuf:"bytes,30,opt,name=Inners,proto3" json:"Inners,omitempty"`
	// ShortBM indicate most used inner node bitmaps.
	// These nodes takes 4 bits and the actual bitmaps are stored separate.
	//
	// Since 0.5.10
	ShortBM *Bitmap `protobuf:"bytes,31,opt,name=ShortBM,proto3" json:"ShortBM,omitempty"`
	// ShortTable is a mapping of short bitmap to full 17-bit bitmap.
	//
	// Since 0.5.10
	ShortTable []uint32 `protobuf:"varint,32,rep,packed,name=ShortTable,proto3" json:"ShortTable,omitempty"`
	// InnerPrefixes of inner nodes.
	// There are two usages with this field:
	// - If inner node prefix is stored, it is a var-len array of stored prefix string.
	// - If only inner node prefix length is stored, it is a array with fixed-size elts. An array elt is the length in 4-bit of a prefix.
	//
	// In full-prefix mode:
	// An array element is a control byte followed by several data bytes.
	//
	// The 0-th bit in the control byte indicates whether a prefix is
	// truncated(not aligned to 8-bit).
	//
	// An inner node may have a prefix, if the starting bit of the node > the end
	// of previous node.
	//
	// The end of a prefix may not be 8-bit aligned.
	// Thus we need a bitmap to indicated this.
	// If prefix length is not 8-bit aligned, the trailing bits a filled with a
	// "1" followed by "0"s.
	// To retrieve the accurate prefix, remove the bits from the last "1".
	// E.g.:
	//
	//   prefix:                  11001100 11000011
	//   stored prefix:  00000000 11001100 11010011;  control byte = 0
	//
	//   prefix:                  11001100 110
	//   stored prefix:  00000001 11001100 11010000;  control byte = 1
	//
	// Since 0.5.10
	InnerPrefixes *VLenArray `protobuf:"bytes,38,opt,name=InnerPrefixes,proto3" json:"InnerPrefixes,omitempty"`
	// LeafPrefixes stores prefix of every leaf if it is not nil.
	// A leaf prefix unlike inner node prefix, is just a byte sequence, without a control byte.
	//
	// Since 0.5.10
	LeafPrefixes *VLenArray `protobuf:"bytes,58,opt,name=LeafPrefixes,proto3" json:"LeafPrefixes,omitempty"`
	// Leaves stores serialized leaf values.
	//
	// Since 0.5.10
	Leaves *VLenArray `protobuf:"bytes,60,opt,name=Leaves,proto3" json:"Leaves,omitempty"`
	// Clustered key suffixes and values.
	//
	// Since 0.5.12
	Clustered            *Clustered `protobuf:"bytes,70,opt,name=Clustered,proto3" json:"Clustered,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Slim) Reset()         { *m = Slim{} }
func (m *Slim) String() string { return proto.CompactTextString(m) }
func (*Slim) ProtoMessage()    {}
func (*Slim) Descriptor() ([]byte, []int) {
	return fileDescriptor_slim_04398d41cb3f85ea, []int{3}
}
func (m *Slim) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Slim.Unmarshal(m, b)
}
func (m *Slim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Slim.Marshal(b, m, deterministic)
}
func (dst *Slim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Slim.Merge(dst, src)
}
func (m *Slim) XXX_Size() int {
	return xxx_messageInfo_Slim.Size(m)
}
func (m *Slim) XXX_DiscardUnknown() {
	xxx_messageInfo_Slim.DiscardUnknown(m)
}

var xxx_messageInfo_Slim proto.InternalMessageInfo

func (m *Slim) GetBigInnerCnt() int32 {
	if m != nil {
		return m.BigInnerCnt
	}
	return 0
}

func (m *Slim) GetShortSize() int32 {
	if m != nil {
		return m.ShortSize
	}
	return 0
}

func (m *Slim) GetNodeTypeBM() *Bitmap {
	if m != nil {
		return m.NodeTypeBM
	}
	return nil
}

func (m *Slim) GetInners() *Bitmap {
	if m != nil {
		return m.Inners
	}
	return nil
}

func (m *Slim) GetShortBM() *Bitmap {
	if m != nil {
		return m.ShortBM
	}
	return nil
}

func (m *Slim) GetShortTable() []uint32 {
	if m != nil {
		return m.ShortTable
	}
	return nil
}

func (m *Slim) GetInnerPrefixes() *VLenArray {
	if m != nil {
		return m.InnerPrefixes
	}
	return nil
}

func (m *Slim) GetLeafPrefixes() *VLenArray {
	if m != nil {
		return m.LeafPrefixes
	}
	return nil
}

func (m *Slim) GetLeaves() *VLenArray {
	if m != nil {
		return m.Leaves
	}
	return nil
}

func (m *Slim) GetClustered() *Clustered {
	if m != nil {
		return m.Clustered
	}
	return nil
}

func init() {
	proto.RegisterType((*Bitmap)(nil), "Bitmap")
	proto.RegisterType((*VLenArray)(nil), "VLenArray")
	proto.RegisterType((*Clustered)(nil), "Clustered")
	proto.RegisterType((*Slim)(nil), "Slim")
}

func init() { proto.RegisterFile("slim.proto", fileDescriptor_slim_04398d41cb3f85ea) }

var fileDescriptor_slim_04398d41cb3f85ea = []byte{
	// 439 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x93, 0x51, 0x8f, 0xd2, 0x40,
	0x14, 0x85, 0xd3, 0x50, 0x0a, 0x5c, 0x60, 0x25, 0x13, 0xd4, 0xfb, 0x60, 0xd8, 0xca, 0x83, 0xf6,
	0x89, 0x18, 0x7d, 0x33, 0xfa, 0x60, 0x37, 0xae, 0x59, 0x02, 0xb8, 0x99, 0x6e, 0x34, 0xf1, 0xc1,
	0xa4, 0xbb, 0xbd, 0xd5, 0x89, 0x65, 0x4a, 0x66, 0x46, 0x03, 0xfe, 0x0f, 0x7f, 0x8b, 0x7f, 0xcf,
	0x74, 0xda, 0x6d, 0x8b, 0xbb, 0x6f, 0xdc, 0xef, 0x9c, 0x39, 0xdc, 0x33, 0x93, 0x02, 0xe8, 0x4c,
	0x6c, 0x17, 0x3b, 0x95, 0x9b, 0x7c, 0xfe, 0x15, 0xbc, 0x50, 0x98, 0x6d, 0xbc, 0x63, 0x53, 0xe8,
	0x7e, 0xce, 0x55, 0xa2, 0x71, 0xea, 0x77, 0x02, 0x97, 0x97, 0x03, 0x7b, 0x02, 0x03, 0x1e, 0xcb,
	0x1f, 0x17, 0x32, 0xa1, 0x3d, 0xce, 0xfc, 0x4e, 0xd0, 0xe5, 0x0d, 0x60, 0x3e, 0x0c, 0x23, 0xca,
	0xe8, 0xc6, 0x94, 0x7a, 0x60, 0xf5, 0x36, 0x9a, 0xff, 0x75, 0x60, 0xf0, 0x69, 0x45, 0xf2, 0x9d,
	0x52, 0xf1, 0x81, 0x8d, 0xc0, 0xd9, 0x20, 0xf8, 0x4e, 0xd0, 0xe5, 0xce, 0x86, 0x3d, 0x02, 0xef,
	0x7d, 0x66, 0xce, 0xa4, 0xc1, 0xa1, 0x45, 0xd5, 0xc4, 0x9e, 0x03, 0x5c, 0x2a, 0xd2, 0x24, 0x6f,
	0x28, 0x5c, 0xe3, 0x5b, 0xdf, 0x09, 0x86, 0x2f, 0x7b, 0x8b, 0x72, 0x4d, 0xde, 0x92, 0xac, 0x31,
	0xd7, 0xc2, 0x88, 0x5c, 0x86, 0x6b, 0x9c, 0xfe, 0x6f, 0xac, 0xa5, 0xa2, 0xc5, 0xb9, 0xd8, 0x53,
	0x12, 0x89, 0xdf, 0x84, 0x8f, 0xed, 0x9f, 0x35, 0xa0, 0x68, 0x1e, 0x1e, 0x0c, 0x69, 0x9c, 0xf9,
	0x4e, 0x30, 0xe2, 0xe5, 0x30, 0x8f, 0x60, 0x70, 0x96, 0xfd, 0xd4, 0x86, 0x14, 0x25, 0xc5, 0xaa,
	0x91, 0x89, 0x95, 0xd1, 0xf8, 0xc1, 0xef, 0x04, 0x63, 0x5e, 0x4d, 0x0c, 0xa1, 0xf7, 0x31, 0x4d,
	0x35, 0x19, 0x8d, 0x43, 0x2b, 0xdc, 0x8e, 0x4d, 0xe8, 0xc3, 0x76, 0xe8, 0x9f, 0x0e, 0xb8, 0x51,
	0x26, 0xb6, 0xc5, 0xcd, 0x85, 0xe2, 0xdb, 0x85, 0x94, 0xa4, 0x9a, 0x0b, 0x68, 0xa3, 0x62, 0xe7,
	0xe8, 0x7b, 0xae, 0x8c, 0xdd, 0xf9, 0xa4, 0xdc, 0xb9, 0x06, 0x45, 0xf5, 0x4d, 0x9e, 0xd0, 0xd5,
	0x61, 0x47, 0xf7, 0x54, 0x6f, 0x24, 0x76, 0x0a, 0x9e, 0x8d, 0x2c, 0xdb, 0xb5, 0x4c, 0x15, 0x66,
	0x4f, 0xa1, 0x67, 0x63, 0xc3, 0x35, 0x9e, 0x1e, 0x3b, 0x6e, 0x39, 0x9b, 0x01, 0xd8, 0x9f, 0x57,
	0xf1, 0x75, 0x46, 0xe8, 0xdb, 0xa2, 0x2d, 0xc2, 0x5e, 0xc0, 0xd8, 0x86, 0x5d, 0x2a, 0x4a, 0xc5,
	0x9e, 0x34, 0x3e, 0xb3, 0x41, 0xb0, 0xa8, 0x5f, 0x9e, 0x1f, 0x1b, 0xd8, 0x02, 0x46, 0x2b, 0x8a,
	0xd3, 0xfa, 0xc0, 0xeb, 0x3b, 0x07, 0x8e, 0x74, 0x36, 0x07, 0x6f, 0x45, 0xf1, 0x2f, 0xd2, 0xf8,
	0xe6, 0x8e, 0xb3, 0x52, 0x58, 0xd0, 0x7a, 0x30, 0x3c, 0xaf, 0x6c, 0x35, 0xe1, 0x8d, 0xb8, 0x74,
	0xfb, 0xa3, 0xc9, 0x78, 0xe9, 0xf6, 0xc7, 0x93, 0x93, 0xa5, 0xdb, 0x7f, 0x30, 0x99, 0x84, 0xde,
	0x17, 0xd7, 0x28, 0x41, 0xd7, 0x9e, 0xfd, 0x2a, 0x5e, 0xfd, 0x0b, 0x00, 0x00, 0xff, 0xff, 0xa6,
	0x99, 0x43, 0xe9, 0x23, 0x03, 0x00, 0x00,
}
